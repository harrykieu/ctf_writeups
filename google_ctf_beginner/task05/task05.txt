Challenge: Twisted robot (misc)
We found this old robo caller. It basically generates random phone numbers to spam. 
We found the last list of numbers in generated and also some weird file... 
Maybe it's got to do with these new beta features they were testing?

Solution:
- Understand the encodeSecret function:
Reading the code in RoboCaller1337.py, I found the function for encoding the secret:
    +-------------------------------------------------------------------+
    |   def encodeSecret(s):                                            |
    |       (1) key = [random.getrandbits(8) for i in range(len(s))]    |
    |       (2) return bytes([a^b for a,b in zip(key,list(s.encode()))])|   
    +-------------------------------------------------------------------+
(1) The list "key" is made by using the random.getrandbits function: For each letter in the secret string, 
add a random number which has 8 bit in binary system
(2) 
+ s.encode() encode the secret string by default method - UTF-8. list(s.encode()) return UTF-8 code of the string
+ "zip" method return a zip object - a tuple in which the 1st elements of key and s.encode() are combined
into a tuple inside the main tuple, and so on
+ a^b is a XOR b (first I thought a^b is a exp b LOL), which basically is convert a and b into binary and compare each 
respectively bit of each number, return 1 if one of the bits is 1 and the other is 0 else returns 0.
Ex: 2 -> 10, 4 -> 100, 2^4 -> 110 -> 6
+ Make a list by using list comprehension: [a^b for a,b in zip(key,list(s.encode()))]
+ Convert the list to bytes object

- Break the random.getrandbits(8) function to find the key
The getrandbits use Mersenne Twister matrix, which would be cracked if you have first 624 32-bit numbers from the 
generator, which was obtained in the number file and the method below:
    +-------------------------------------------------------------------------------+
    |   def generateRandomNumbers():                                                |
    |       arr = []                                                                |
    |       for i in range(624):                                                    |
    |           arr.append(formatNumber(random.getrandbits(32) + (1<<31)))          |
    |       return arr                                                              |
    |                                                                               |
    |   def formatNumber(n):                                                        |
    |       n = str(n)                                                              |
    |       return f'{n[:3]}-{n[3:6]}-{n[6:]}'                                      |
    +-------------------------------------------------------------------------------+
The method generateRandomNumbers generated 624 32-bit number, then add 1<<31 (2147483648). Finally, it call 
formatNumber function, which format the generated numbers to the form abc-def-....
The file secret.enc has 31 bytes -> need key - 31 numbers generated by encodeSecret function to decode
=>  take the 624 numbers generated before by generateRandomNumbers() function (removed the dash and saved in number.txt)
minus 1<<31, load into the Randcrack, then using Randcrack() to predict the pre-generated key

- Find the flag
The reverse function of XOR is XOR itself, and when we know 2 of 3 element in XOR function, we can find the remaining 
element (i.g a^b = c -> b = c^a) 
-> Using the key and the byte read on secret.enc, we can find the flag
I coded the decodefunction.py file and found the flag: CTF{n3v3r_3ver_ev3r_use_r4nd0m}

